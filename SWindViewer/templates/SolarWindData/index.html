<html>
  <head>
    <title>Viento Solar en Tiempo Real</title>
    <link rel="icon" href="static/images/sun.png" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Slab:400,100" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200" rel="stylesheet" type="text/css">
<style>

   /* CSS  */
   body {
    font: 300 13px/18px 'Helvetica Neue', sans-serif;
    color: #000000;
    margin: 0px auto;
    background-color: rgba(255, 253, 242, 0.932)
  }

.TITLE {  
  padding: 50px 0;
  margin-bottom: 5px;
  background-color: rgba(255, 253, 242, 0.932)
  }

.date { 
    margin-top: 15px; 
  text-align:center;
  font-size: 1.2em;
  font-family: Georgia, 'Times New Roman', Times, serif
}

.last-update { 
   text-align:center;
   font-size: 0.8em; 
   font-family: Georgia, 'Times New Roman', Times, serif
}

.maintitle {
  text-align: center;
  font-size: 2.5em; 
  color: #000000;
  margin-top: 0px; 
  margin-bottom: 5px; 
  font-family: Georgia, 'Times New Roman', Times, serif;  
 }

.all-graphs { 
  display: flex;
  flex-direction: column; 
  align-items: center; 
  padding: 40px;
  overflow: hidden; 
  margin-top: 0px;
}

.small-graphs {
  width: 100%; 
  margin: 0px 0; 
  overflow: hidden;
  background: rgba(255, 253, 242, 0.932);
}

 .title {
      width: 100%;
      background: rgba(230, 214, 246, 0.096);
      text-align: center;
      cursor: pointer;
    }

.axis text {
  font-family: sans-serif, sans-serif;
  font-size: 13px;
  fill: rgb(122, 122, 120); 
}

.tooltip {
            position: absolute;
            text-align: center;
            padding: 5px;
            font: 12px sans-serif;
            background: #9575cd ;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s; 
            z-index: 10;  
}

  /* Responsive Design */
  @media (max-width: 768px) {
            .small-graphs {
                width: 100%; 
            }
        }


      </style>
  </head>
  <body>
      <div class="TITLE">
           <div class="maintitle">Viento Solar en Tiempo Real</div>
           <div class="date" id="currentDate" ></div>
           <div class="last-update"id="lastupdate"></div>
      </div>
     <div class="all-graphs">
        <div id="chart1" class="graph-1 small-graphs">
          
               <div class="tooltip"></div>
        </div>
        <div id="chart0" class="graph-0 small-graphs">
          
              <div class="tooltip"></div>
        </div>
        <div id="chart2" class="graph-2 small-graphs">
            
               <div class="tooltip"></div>
        </div>
        <div id="chart3" class="graph-3 small-graphs">
  
          <div class="tooltip"></div>
    </div>
  </div>

  <!--moment.js-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
  <!-- jQuery library -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script> 
  <!-- Latest compiled JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script> 
  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v7.js"></script>
<script>

//check if it is the first time loading
let isFirstLoad = true; 

// Function to fetch data and update the graph
function fetchData() {
    fetch('/api')
        .then(response => response.json())
        .then(data => {  
          if (isFirstLoad) {
                graph(data); 
                updateLastUpdate();
                isFirstLoad = false;
            } else {
                graph(data); 
                updateLastUpdate();
            }
        })
        .catch(error => console.log('Error fetching data:', error));
}

// Call fetchData every min
setInterval(fetchData, 300000);

// Initial call to fetch data immediately on page load
fetchData();
 
//lugar dde se va a guardar la data 
let currentData = {
    PlasmaData: [],
    MagData: []
};

function graph(data) {

    if (isFirstLoad) {
         // Si es la primera vez, guarda todos los datos iterados en currentData
         console.log("raw data",data)
    //parse time
    const parseTime = function(timeString) {
    const date = moment(timeString, 'YYYY-MM-DD HH:mm:ss.SSS');
         return date.isValid() ? date.toDate() : null;  
         };

    //diffierentiate data in labels
    const PlasmaData = data.labelsplasma.map((label, index) => {
    const PlasmaDate = parseTime(label);
        return {
            date: PlasmaDate,
            chartspeed: data.chartspeed?.[index] || 0,
            chartemperature: data.chartemperature?.[index] || 0,
            chartdensity: data.chartdensity?.[index] || 0,
        };
    }).filter((d) => {

    // Filter null or NaN
         return [d.chartspeed, d.chartemperature, d.chartdensity].some(value => !isNaN(value));
        
        });
    //diffierentiate data in labels
    const Kp_indx = data.labelskp.map((label, index) => {
        const KpDate = parseTime(label);
             return {
                date: KpDate,
                kp:data.kp?.[index],
                noaa_scale: data.noaa_scale?.[index], 
            };
     });

     //diffierentiate data in labels
    const MagData = data.labelsmag.map((label, index) => {
        const MagDate = parseTime(label);
             return {
                date: MagDate,
                chartbx: data.chartbx?.[index] || 0,
                chartby: data.chartby?.[index] || 0,
                chartbz: data.chartbz?.[index] || 0,
            };
     }).filter((d) => {

     // Filter null or NaN
             return [d.chartbx, d.chartby, d.chartbz,d.chartblon,d.chartlat,d.chartbt].some(value => !isNaN(value));
     });
         currentData.PlasmaData = PlasmaData;
        currentData.MagData = MagData;
        
        console.log("scale:",Kp_indx)

        createChart(Kp_indx,'#chart0', PlasmaData, 'chartspeed', '(km/s)', 'Velocidad', '#8e44ad');

        createChart(Kp_indx,'#chart1', PlasmaData, 'chartdensity', '(1/cm^3)', 'Densidad', '#4a148c ');

        createChart(Kp_indx,'#chart2', PlasmaData, 'chartemperature', 'K', 'Temperatura', '#7b1fa2');

        createChart(Kp_indx,'#chart3', MagData, 'chartbx', 'nT', 'BX ', '#9575cd ');

        //createChart('#chart3', MagData, 'chartby', 'nT', 'BY', '#00796b');

        //createChart('#chart3', MagData, 'chartbz', 'nT', ' BZ', '#673ab7 ');
    } 
    
    else {
        console.log("raw data",data)
    //parse time
    const parseTime = function(timeString) {
    const date = moment(timeString, 'YYYY-MM-DD HH:mm:ss.SSS');
         return date.isValid() ? date.toDate() : null;  
         };


     //diffierentiate data in labels
    const PlasmaData = data.labelsplasma.map((label, index) => {
    const PlasmaDate = parseTime(label);
        return {
            date: PlasmaDate,
            chartspeed: data.chartspeed?.[index] || 0,
            chartemperature: data.chartemperature?.[index] || 0,
            chartdensity: data.chartdensity?.[index] || 0,
        };
    }).filter((d) => {

    // Filter null or NaN
         return [d.chartspeed, d.chartemperature, d.chartdensity].some(value => !isNaN(value));
        
        });

     //diffierentiate data in labels
     const Kp_indx = data.labelskp.map((label, index) => {
        const KpDate = parseTime(label);
             return {
                date: KpDate,
                kp:data.kp?.[index],
                noaa_scale: data.noaa_scale?.[index], 
            };
     });

    //diffierentiate data in labels
    const MagData = data.labelsmag.map((label, index) => {
        const MagDate = parseTime(label);
             return {
                date: MagDate,
                chartbx: data.chartbx?.[index] || 0,
                chartby: data.chartby?.[index] || 0,
                chartbz: data.chartbz?.[index] || 0,
            };
     }).filter((d) => {

     // Filter null or NaN
             return [d.chartbx, d.chartby, d.chartbz,d.chartblon,d.chartlat,d.chartbt].some(value => !isNaN(value));
     });

        const lastPlasmaData = PlasmaData.slice(-5);
        const lastMagData = MagData.slice(-5);
    
        console.log ("nuevos:",lastPlasmaData)
        let NewData_mag= MagData;

        let NewData_plasma= PlasmaData;

        currentData.PlasmaData = [...currentData.PlasmaData, ...lastPlasmaData];
        currentData.MagData = [...currentData.MagData, ...lastMagData];

       if (currentData.PlasmaData.length > 1440) {
            currentData.PlasmaData = currentData.PlasmaData.slice(-1440);
        }
        if (currentData.MagData.length > 1440) {
            currentData.MagData = currentData.MagData.slice(-1440);
                        }
        console.log("new data:",MagData);

        console.log("new data:",PlasmaData);

        UpdateChart(Kp_indx,'#chart3', MagData, 'chartbx', '#9575cd ');

        UpdateChart(Kp_indx,'#chart0', PlasmaData, 'chartspeed', '#8e44ad');

        UpdateChart(Kp_indx,'#chart1',  PlasmaData, 'chartdensity','#673ab7 ');

        UpdateChart(Kp_indx,'#chart2', PlasmaData, 'chartemperature', '#7b1fa2 ');

         }
    }

function createChart(Kp_indx,containerId, dataSet, yAccessor, yLabel, titleText, lineColor) {
    // select chart 
    const chart = d3.select(containerId);
     
    // margins of the page
    const margin = { top:25, right: 10, bottom: 100, left: 60 };
    const width = 1320 - margin.left - margin.right;
    const height =180 - margin.top - margin.bottom;

    //SVG
    const svg = chart.append('svg')
        .attr('width','100%')
        .attr('height','100%')
        .append('g')
        .attr('transform',`translate(${margin.left}, 45)`);

    //Scales
    const xScale = d3.scaleTime()
        .domain(d3.extent(dataSet, d => d.date))
        .range([0, width]);

    const minY = d3.min(dataSet.filter(d => d[yAccessor] !== 0), d => {
        const value = parseFloat(d[yAccessor]);
            return value; 
        });

    const maxY = d3.max(dataSet, d => {
        const value = parseFloat(d[yAccessor]);
            return value; 
        });

    console.log("Min Value:", minY); 
    console.log("Max Value:", maxY); 

    const yScale = d3.scaleLinear()
        .domain([minY, maxY])
        .range([height, 0])
        .nice();

    // Add the lines
    const line = d3.line() 
        .x(d => xScale(d.date))
        .y(d => yScale(d[yAccessor]))
        .defined(d => d[yAccessor] !== 0 && d[yAccessor] !== null && !isNaN(d[yAccessor]) || (d[yAccessor] < 0 || d[yAccessor] > 0));

    const linePath = svg.append("path")
        .data([dataSet])
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", 'rgb( 154, 157, 154)')
        .attr("stroke-width", 1)
        .attr("d", line(dataSet))
        .attr("clip-path", "url(#clip)");
     
       function getColorsAndIn(yAccessor) {

            let parameter = yAccessor

            const colorsAndIndexes = [          
            {speed: 1000, density: 10000,temperature:100000000,bx:-10, backgroundColor: '#c80000',  opacity: 1.2 },
            {speed: 900, density: 5000,temperature:6000000,bx:-5, backgroundColor: '#ff0000',  opacity: 1},
            { speed: 800, density: 4000,temperature:50000000,bx:-1, backgroundColor: '#ff9600',  opacity: 0.9 },
            { speed: 700, density: 1000,temperature:10000000,bx:0, backgroundColor: '#ffc800',  opacity: 0.8 },
            { speed: 600, density: 100,temperature:5000000,bx:10, backgroundColor: '#f6eb14',  opacity: 0.7 },
            { speed: 500, density: 10,temperature:1000000,bx:5, backgroundColor: '#92d050',  opacity: 0.6 },
            ];

            var max= d3.max(dataSet, d => {
        const value = parseFloat(d[yAccessor]);
            return value}); 

        for (var color in colorsAndIndexes) {
            if (colorsAndIndexes.hasOwnProperty(color)) {
                if(colorsAndIndexes[color].offset === undefined) {
                    if(!isNaN((1 - colorsAndIndexes[color].parameter / max) * 100)
                     && isFinite((1 - colorsAndIndexes[color].parameter / max) * 100) 
                     && (1 - colorsAndIndexes[color].parameter / max) * 100 !== NaN) {
                    colorsAndIndexes[color].offset = (1 - colorsAndIndexes[color].parameter / max) * 100;
                } else {
                    colorsAndIndexes[color].offset = 32;
                }
            }
        }
    }
    console.log(colorsAndIndexes)      
svg.append('defs')
    .append('linearGradient')
    .attr('gradientUnits', 'userSpaceOnUse').attr('id', 'gradient-area')
    .attr('x1', 0).attr('y1', 0).attr('x2', 0).attr('y2', yScale(0))
    .selectAll('stop')
    .data(colorsAndIndexes) 
    .enter().append('stop')
    .attr('offset', function(d) { return d.offset + '%'; })
    .attr('style', function(d) { return 'stop-color:' + d.backgroundColor + ';stop-opacity:' + d.opacity; });
        }
  
getColorsAndIn(yAccessor);

console.log("elkp",Kp_indx)


     // define the area
     var area = d3.area()
    .x(d => xScale(d.date))
    .y0(height)
    .y1(d => yScale(d[yAccessor]));

    var defs = svg.append("defs");

//clipping path to avoid elements spilling out
svg.append("defs").append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("x", 0)
    .attr("width", width)
    .attr("height", height);

  // add first area
  svg.append("path")
      .data([dataSet])
      .attr("class", "area")
      .attr('d', area)
      .attr('style', 'fill: url(#gradient-area);')
      .attr("clip-path", "url(#clip)");

    //zoom 
    const zoom = d3.zoom()
        .scaleExtent([1, 120])
        .translateExtent([[0, 0], [width, height]])
        .extent([[0, 0], [width, height]])
        .on('zoom', zoomed);

     //apply zoom to the graph
     svg.append('rect')
        .attr('width', width)
        .attr('height', height)
        .style("fill", "none")
        .style('pointer-events', 'all')
        .attr("transform", `translate(${margin.left}, ${margin.top})`)
        .call(zoom);

    function zoomed(event) {
        const new_xScale = event.transform.rescaleX(xScale);
 
        svg.select('.x-axis')
            .call(d3.axisBottom(new_xScale).tickFormat(d3.timeFormat('%H:%M')));

        svg.select('.line')
            .attr('d', line.x(d => new_xScale(d.date)));
        
        svg.select('.area')
            .attr('d', area.x(d => new_xScale(d.date)));
           
        svg.selectAll('.dot')
        .attr('cx', d => new_xScale(d.date))
        .attr('cy', d => yScale(d[yAccessor]));

         // Determine the scale factor
         const scaleFactor = event.transform.k;

        // Set a threshold for visibility; adjust this value as needed
         const visibilityThreshold = 5; // This means dots will be visible when zoomed in more than 5 times

        svg.selectAll('.dot')
            .style('opacity', scaleFactor > visibilityThreshold ? 1 : 0); // Show dots if zoomed in enough
     }

    //X axis
    svg.append("g")
        .attr("class", "x-axis")
        .attr("clip-path", "url(#clip)")
        .style("color",'rgb(154, 157, 154)')
        .attr("stroke-width", 3)
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M')));

    //Y axis
    svg.append("g")
        .attr("class", "y-axis")
        .attr("stroke-width", 1)
        .style("color",'rgb( 154, 157, 154)')
        .call(d3.axisLeft(yScale)
        .ticks(4)
        .tickFormat(function(d) {
            return d > 9999 ? d3.format(".2e")(d) : d3.format(",.0f")(d);
         }))
        .call(g => g.selectAll(".tick line").clone()
        .attr("x2", width )
        .attr("stroke-opacity", 0.1));
      
    //Y label 
    svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left +10)
        .attr("x", -height / 2)
        .attr("dy", "0.5em")
        .style("text-anchor", "middle")
        .text(yLabel)
        .style("fill",'rgb( 154, 157, 154)') 
        .style("font-weight", "bold"); 

    //chart title
    svg.append("text")
        .attr("x", width-1215)
        .attr("y", -15 )
        .attr("text-anchor", "middle")
        .attr("font-size", "15px")
        .attr("fill",' black') 
        .style("font-family", "Georgia, 'Times New Roman', Times, serif")
        .style("font-weight", "bold")
        .text(titleText);

    // Create a group for the dots
    const dotsGroup = svg.append('g')
        .attr('clip-path', 'url(#clip)');

    // Append the dots but set their initial opacity to 0
    const dots = dotsGroup.selectAll('.dot')
        .data(dataSet)
        .enter().append('circle')
        .attr('class', 'dot')
        .attr('cx', d => xScale(d.date))
        .attr('cy', d => yScale(d[yAccessor]))
        .attr('r', 1) // Set a larger radius for visibility
        .attr('fill','rgb( 154, 157, 154)')
        .style('opacity', 0.5) // Initially hidden
        .on('mouseover', function(event, d) {
            d3.select(this).transition().duration(200).attr('fill', 'orange').attr('r', 5);
            tooltip.transition().duration(200).style('opacity', 0.9);
            const [x, y] = d3.pointer(event, this);
            tooltip.html(`Fecha: ${d3.timeFormat('%d %b %H:%M')(d.date)}<br/>Valor: ${d[yAccessor]}`)
                .style('left', (event.pageX + 5) + 'px')
                .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
            d3.select(this).transition().duration(200).attr('fill', 'rgb( 154, 157, 154)').attr('r', 3);
            tooltip.transition().duration(200).style('opacity', 0);
        });

    // Add mouse events to the line
    linePath.on('mouseover', function() {
        d3.select(this).style('opacity', 1); 
        })
        .on('mousemove', function(event) {
            const mouseX = d3.pointer(event)[0]; // Get mouse X position
            const x0 = xScale.invert(mouseX); // Convert mouse X to the corresponding date
            const index = d3.bisectLeft(dataSet.map(d => d.date), x0); // Find the index of the closest date        
            // Select the nearest data point
            const closestDataPoint = dataSet[index];        
            // Highlight the closest dot
            if (closestDataPoint) {
                dots.transition().duration(200).style('opacity', 0); // Hide all dots
                d3.select(dots.nodes()[index]).transition().duration(200).attr('fill', 'orange').attr('r', 5); // Highlight the closest dot
                }
         })
        .on('mouseout', function() {
            dots.style('opacity', 0); // Hide dots when not hovering
            });

    // Tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0)
        .style('position', 'absolute') // Ensure the tooltip is absolutely positioned
        .style('pointer-events', 'none'); // Prevent mouse events from interfering
        }

// Función para actualizar la fecha y hora
function updateDate() {
    const now = new Date();
    const formattedDate = now.toLocaleString(); // Formato de fecha y hora
    d3.select('#currentDate') // Selecciona el elemento con id 'currentDate'
        .text(formattedDate); // Actualiza el texto
        }

// Llama a la función al cargar la página
updateDate();
// Actualiza cada minuto (60000 ms)
setInterval(updateDate, 1000);


function updateLastUpdate() {
    const now = new Date();
    const formattedTime = now.toLocaleTimeString(); // Formato de hora y minuto
    d3.select('#lastUpdate') // Selecciona el elemento con id 'lastUpdate'
    .text(`Última actualización: ${formattedTime}`); // Actualiza el texto
    }


function UpdateChart(Kp_indx,containerId, dataSet, yAccessor,lineColor){
    console.log("Y:",yAccessor)
    // select chart 
    const chart = d3.select(containerId);
    // margins of the page
    const margin = { top:25, right: 10, bottom: 100, left: 60 };
    const width = 1320 - margin.left - margin.right;
    const height =180 - margin.top - margin.bottom;

    // Seleccionar el contenedor SVG y eliminar los elementos anteriores
    let svg = chart.select("svg");
    svg.selectAll('.line').remove();
    svg.selectAll('.dot').remove();
    svg.selectAll('.x-axis').remove();
    svg.selectAll('.y-axis').remove();
    svg.selectAll('.tooltip').remove();
    svg.selectAll('.linePath').remove();
    svg.selectAll('.rect').remove();
    svg.selectAll('.area').remove();

    if (svg.empty()) {
        svg = chart.append('svg')
        .attr('width','100%')
        .attr('height','100%')
        .append('g')
        .attr('transform',`translate(${margin.left}, 45)`);

    } else {
        svg = svg.select('g');
    }

    //Scales
    const xScale = d3.scaleTime()
        .domain(d3.extent(dataSet, d => d.date))
        .range([0, width+10]);

    const minY = d3.min(dataSet.filter(d => d[yAccessor] !== 0), d => {
        const value = parseFloat(d[yAccessor]);
        return value; 
    });
    
    const maxY = d3.max(dataSet, d => {
    const value = parseFloat(d[yAccessor]);
        return value; 
    });

    console.log("Min Value:", minY); 
    console.log("Max Value:", maxY); 

    const yScale = d3.scaleLinear()
        .domain([minY, maxY])
        .range([height, 0])
        .nice();

    //line graph 
    const line = d3.line()
        .x(d => xScale(d.date))
        .y(d => yScale(d[yAccessor]))
        .defined(d => d[yAccessor] !== 0 && d[yAccessor] !== null && !isNaN(d[yAccessor]) || (d[yAccessor] < 0 || d[yAccessor] > 0));

    //append line
    const linePath = svg.append("path")
        .data([dataSet])
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke",'rgb( 154, 157, 154)')
        .attr("stroke-width", 1)
        .attr("d", line(dataSet))
        .attr("clip-path", "url(#clip)");

    
        function getColorsAndIn(yAccessor) {

let parameter = yAccessor

const colorsAndIndexes = [          
{speed: 1000, density: 10000,temperature:100000000,bx:-10, backgroundColor: '#c80000',  opacity: 0.75 },
{speed: 900, density: 5000,temperature:6000000,bx:-5, backgroundColor: '#ff0000',  opacity: 0.7},
{ speed: 800, density: 4000,temperature:50000000,bx:-1, backgroundColor: '#ff9600',  opacity: 0.65 },
{ speed: 700, density: 1000,temperature:10000000,bx:0, backgroundColor: '#ffc800',  opacity: 0.6 },
{ speed: 600, density: 100,temperature:5000000,bx:10, backgroundColor: '#f6eb14',  opacity: 0.55 },
{ speed: 500, density: 10,temperature:1000000,bx:5, backgroundColor: '#92d050',  opacity: 0.5 },
];

var max= d3.max(dataSet, d => {
const value = parseFloat(d[yAccessor]);
return value}); 

for (var color in colorsAndIndexes) {
if (colorsAndIndexes.hasOwnProperty(color)) {
    if(colorsAndIndexes[color].offset === undefined) {
        if(!isNaN((1 - colorsAndIndexes[color].speed / max) * 100)
         && isFinite((1 - colorsAndIndexes[color].speed / max) * 100) 
         && (1 - colorsAndIndexes[color].speed / max) * 100 !== NaN) {
        colorsAndIndexes[color].offset = (1 - colorsAndIndexes[color].speed / max) * 100;
    } else {
        colorsAndIndexes[color].offset = 32;
    }
}
}
}
console.log(colorsAndIndexes)      
svg.append('defs')
.append('linearGradient')
.attr('gradientUnits', 'userSpaceOnUse').attr('id', 'gradient-area')
.attr('x1', 0).attr('y1', 0).attr('x2', 0).attr('y2', yScale(0))
.selectAll('stop')
.data(colorsAndIndexes) 
.enter().append('stop')
.attr('offset', function(d) { return d.offset + '%'; })
.attr('style', function(d) { return 'stop-color:' + d.backgroundColor + ';stop-opacity:' + d.opacity; });
}

getColorsAndIn(yAccessor);


    // define the area
    var area = d3.area()
    .x(d => xScale(d.date))
    .y0(height)
    .y1(d => yScale(d[yAccessor]));

    var defs = svg.append("defs");

    //clipping path to avoid elements spilling out
    svg.append("defs").append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("x", 0)
    .attr("width", width)
    .attr("height", height);

     // add first area
    svg.append("path")
      .data([dataSet])
      .attr("class", "area")
      .attr('d', area)
      .attr('style', 'fill: url(#gradient-area);')
      .attr("clip-path", "url(#clip)");


    const zoom = d3.zoom()
        .scaleExtent([1, 240])
        .translateExtent([[0, 0], [width+10, height]])
        .extent([[0, 0], [width+10, height]])
        .on('zoom', zoomed);

        //apply zoom to the graph
     svg.append('rect')
        .attr('width', width)
        .attr('height', height)
        .style("fill", "none")
        .style('pointer-events', 'all')
        .attr("transform", `translate(${margin.left}, ${margin.top})`)
        .call(zoom);

    function zoomed(event) {
        
        const new_xScale = event.transform.rescaleX(xScale);

        svg.select('.x-axis')
            .call(d3.axisBottom(new_xScale).tickFormat(d3.timeFormat('%H:%M')));

        svg.select('.line')
            .attr('d', line.x(d => new_xScale(d.date)));

        svg.select('.area')
            .attr('d', area.x(d => new_xScale(d.date)));

        svg.selectAll('.dot')
            .attr('cx', d => new_xScale(d.date))
            .attr('cy', d => yScale(d[yAccessor]));
        }

    // Clipping path
    svg.append("defs").append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("x", 0)
        .attr("width", width)
        .attr("height", height);

    // X Axis
    svg.append("g")
        .attr("class", "x-axis")
        .attr("clip-path", "url(#clip)")
        .attr("stroke-width", 1)
        .style("color",'rgb(154, 157, 154)')
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M')));

    // Y Axis
    svg.append("g")
        .attr("class", "y-axis")
        .attr("stroke-width", 1)
        .style("color",'rgb( 154, 157, 154)')
        .call(d3.axisLeft(yScale)
            .ticks(4)
            .tickFormat(function(d) {
                return d > 9999 ? d3.format(".2e")(d) : d3.format(",.0f")(d);
            }))

        .call(g => g.selectAll(".tick line").clone()
            .attr("x2", width)
            .attr("stroke-opacity", 0.1));
        // Create a group for the dots
        const dotsGroup = svg.append('g')
        .attr('clip-path', 'url(#clip)');

        // Append the dots   
        const dots = dotsGroup.selectAll('.dot')
        .data(dataSet)
        .enter().append('circle')
        .attr('class', 'dot')
        .attr('cx', d => xScale(d.date))
        .attr('cy', d => yScale(d[yAccessor]))
        .attr('r', 1) // Set a larger radius for visibility
        .attr('fill','rgb( 154, 157, 154)')
        .style('opacity', 0.5) // Initially hidden
        .on('mouseover', function(event, d) {
            d3.select(this).transition().duration(200).attr('fill', 'orange').attr('r', 5);
            tooltip.transition().duration(200).style('opacity', 0.9);
            const [x, y] = d3.pointer(event, this);
            tooltip.html(`Fecha: ${d3.timeFormat('%d %b %H:%M')(d.date)}<br/>Valor: ${d[yAccessor]}`)
                .style('left', (event.pageX + 5) + 'px')
                .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
            d3.select(this).transition().duration(200).attr('fill', 'rgb( 154, 157, 154)').attr('r', 3);
            tooltip.transition().duration(200).style('opacity', 0);
        });

    // Tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0)
        .style('position', 'absolute') // Ensure the tooltip is absolutely positioned
        .style('pointer-events', 'none'); // Prevent mouse events from interfering

        console.log("data en linea:",dataSet)

}

</script>
  </body>
</html>