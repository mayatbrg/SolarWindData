<html>
  <head>
    <title>Viento Solar en Tiempo Real</title>
    <link rel="icon" href="staticfiles/images/sun.png" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Slab:400,100" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200" rel="stylesheet" type="text/css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

<style>

   /* CSS  */
   body {
    font-family: 'Roboto', sans-serif;
    font: 300 13px/18px;
    color: #000000;
    margin: 0px auto;
    padding: 0;
    background-color: rgba(255, 253, 242, 0.932);
  }

.TITLE {  
  padding: 50px 0;
  margin-bottom: 5px;
  background-color: rgba(255, 253, 242, 0.932)
  }

.date { 
    margin-top: 15px; 
  text-align:center;
  font-size: 1.2em;
  font-family: 'Roboto', sans-serif;
}

.last-update { 
   text-align:center;
   font-size: 0.8em; 
   font-family: 'Roboto', sans-serif;
}

.maintitle {
  text-align: center;
  font-size: 2.5em; 
  color: #000000;
  margin-top: 0px; 
  margin-bottom: 5px; 
  font-family: '';  
 }

.all-graphs { 
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  flex-direction: column; 
  align-items: center; 
  padding: 0px;
  overflow: hidden; 
  width: 100%;
  margin-top: 0px;
  height: auto;
  width: 100vw; 
}


.small-graphs {
  margin: 5px 0;  
  width: 100%; 
  height: 200px; /* Set a height for the small graphs */
  /* Add some margin for spacing */
  background: rgba(255, 253, 242, 0.932);
  display: flex; /* Enable flexbox for the small graphs */
  justify-content: center; /* Center the content horizontally */
  overflow: hidden;
  background: rgba(255, 253, 242, 0.932);
  margin-top: 10px; /* Add some margin to the top */;
  border-radius: 10px;
  border-radius: 10px;
  flex-grow: 1;
}

 .title {
      font-family: 'Roboto', sans-serif;
      width: 100%;
      background: rgba(230, 214, 246, 0.096);
      text-align: center;
      cursor: pointer;
    }

.axis text {
  font-family: sans-serif, sans-serif;
  font-size: 13px;
  fill: rgb(122, 122, 120); 
}

.label-bx {
    fill: #e74c3c;
    font-family: 'Roboto', sans-serif;
    font-size: 14px;
    color: darkgray;
}

.label-by {
    fill: #00796b;
    font-family: 'Roboto', sans-serif;
    font-size: 14px;
    color: darkgray;
}

.label-bz {
    fill: #673ab7;
    font-family: 'Roboto', sans-serif;
    font-size: 14px;
    color: darkgray;
}

.tooltip {
            position: absolute;
            text-align: center;
            padding: 5px;
            font: 12px sans-serif;
            background: #9575cd ;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s; 
            z-index: 10;  
}

  /* Responsive Design */
  @media (max-width: 768px) {
 
    .small-graphs {
        height: 120px; /* Ajusta la altura para pantallas pequeñas */
        margin: 5px 0;
        padding: 20px; /* Reduce el margen */
    }
  }

        
      </style>
  </head>
  <body>
      <div class="TITLE">
           <div class="maintitle">Viento Solar en Tiempo Real</div>
           <div class="date" id="currentDate" ></div>
           <div class="last-update"id="lastupdate"></div>
      </div>
     <div class="all-graphs">
        <div id="chart1" class="graph-1 small-graphs">
          
               <div class="tooltip"></div>
        </div>
        <div id="chart0" class="graph-0 small-graphs">
          
              <div class="tooltip"></div>
        </div>
        <div id="chart2" class="graph-2 small-graphs">
            
               <div class="tooltip"></div>
        </div>
        <div id="chart3" class="graph-3 small-graphs">
  
          <div class="tooltip"></div>
    </div>
  </div>

  <!--moment.js-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
  <!-- jQuery library -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script> 
  <!-- Latest compiled JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script> 
  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v7.js"></script>
<script>

//check if it is the first time loading
let isFirstLoad = true; 

// Function to fetch data and update the graph
function fetchData() {
    fetch('/api')
        .then(response => response.json())
        .then(data => {  
          if (isFirstLoad) {
                graph(data); 
                updateLastUpdate();
                isFirstLoad = false;
            } else {
                graph(data); 
                updateLastUpdate();
            }
        })
        .catch(error => console.log('Error fetching data:', error));
}

// Call fetchData every min
setInterval(fetchData, 300000);

// Initial call to fetch data immediately on page load
fetchData();
 
//lugar dde se va a guardar la data 
let currentData = {
    PlasmaData: [],
    MagData: []
};

function graph(data) {

    if (isFirstLoad) {
         // Si es la primera vez, guarda todos los datos iterados en currentData
         console.log("raw data",data)
    //parse time
    const parseTime = function(timeString) {
    const date = moment(timeString, 'YYYY-MM-DD HH:mm:ss.SSS');
         return date.isValid() ? date.toDate() : null;  
         };

    //diffierentiate data in labels
    const PlasmaData = data.labelsplasma.map((label, index) => {
    const PlasmaDate = parseTime(label);
        return {
            date: PlasmaDate,
            chartspeed: data.chartspeed?.[index] || 0,
            chartemperature: data.chartemperature?.[index] || 0,
            chartdensity: data.chartdensity?.[index] || 0,
        };
    }).filter((d) => {

    // Filter null or NaN
         return [d.chartspeed, d.chartemperature, d.chartdensity].some(value => !isNaN(value));
        
        });
    //diffierentiate data in labels
    const Kp_indx = data.labelskp.map((label, index) => {
        const KpDate = parseTime(label);
             return {
                date: KpDate,
                kp:data.kp?.[index],
                noaa_scale: data.noaa_scale?.[index], 
            };
     });

     //diffierentiate data in labels
    const MagData = data.labelsmag.map((label, index) => {
        const MagDate = parseTime(label);
             return {
                date: MagDate,
                chartbx: data.chartbx?.[index] || 0,
                chartby: data.chartby?.[index] || 0,
                chartbz: data.chartbz?.[index] || 0,
            };
     }).filter((d) => {

     // Filter null or NaN
             return [d.chartbx, d.chartby, d.chartbz,d.chartblon,d.chartlat,d.chartbt].some(value => !isNaN(value));
     });
         currentData.PlasmaData = PlasmaData;
        currentData.MagData = MagData;
        
        console.log("scale:",Kp_indx)

        createChart(Kp_indx,'#chart0', PlasmaData, 'chartspeed', '(km/s)', 'Velocidad', '#8e44ad');

        createChart(Kp_indx,'#chart1', PlasmaData, 'chartdensity', '(1/cm^3)', 'Densidad', '#4a148c ');

        createChart(Kp_indx,'#chart2', PlasmaData, 'chartemperature', 'K', 'Temperatura', '#7b1fa2');

        createCombinedMagChart('#chart3', MagData, 'Magnetic Field','nT');

    } 
    
    else {
        console.log("raw data",data)
    //parse time
    const parseTime = function(timeString) {
    const date = moment(timeString, 'YYYY-MM-DD HH:mm:ss.SSS');
         return date.isValid() ? date.toDate() : null;  
         };


     //diffierentiate data in labels
    const PlasmaData = data.labelsplasma.map((label, index) => {
    const PlasmaDate = parseTime(label);
        return {
            date: PlasmaDate,
            chartspeed: data.chartspeed?.[index] || 0,
            chartemperature: data.chartemperature?.[index] || 0,
            chartdensity: data.chartdensity?.[index] || 0,
        };
    }).filter((d) => {

    // Filter null or NaN
         return [d.chartspeed, d.chartemperature, d.chartdensity].some(value => !isNaN(value));
        
        });

     //diffierentiate data in labels
     const Kp_indx = data.labelskp.map((label, index) => {
        const KpDate = parseTime(label);
             return {
                date: KpDate,
                kp:data.kp?.[index],
                noaa_scale: data.noaa_scale?.[index], 
            };
     });

    //diffierentiate data in labels
    const MagData = data.labelsmag.map((label, index) => {
        const MagDate = parseTime(label);
             return {
                date: MagDate,
                chartbx: data.chartbx?.[index] || 0,
                chartby: data.chartby?.[index] || 0,
                chartbz: data.chartbz?.[index] || 0,
            };
     }).filter((d) => {

     // Filter null or NaN
             return [d.chartbx, d.chartby, d.chartbz,d.chartblon,d.chartlat,d.chartbt].some(value => !isNaN(value));
     });

        const lastPlasmaData = PlasmaData.slice(-5);
        const lastMagData = MagData.slice(-5);
    
        console.log ("nuevos:",lastPlasmaData)
        let NewData_mag= MagData;

        let NewData_plasma= PlasmaData;

        currentData.PlasmaData = [...currentData.PlasmaData, ...lastPlasmaData];
        currentData.MagData = [...currentData.MagData, ...lastMagData];

       if (currentData.PlasmaData.length > 1440) {
            currentData.PlasmaData = currentData.PlasmaData.slice(-1440);
        }
        if (currentData.MagData.length > 1440) {
            currentData.MagData = currentData.MagData.slice(-1440);
                        }
        console.log("new data:",MagData);

        console.log("new data:",PlasmaData);

        UpdateChart(Kp_indx,'#chart3', MagData, 'chartbx', '#9575cd ');

        UpdateChart(Kp_indx,'#chart0', PlasmaData, 'chartspeed', '#8e44ad');

        UpdateChart(Kp_indx,'#chart1',  PlasmaData, 'chartdensity','#673ab7 ');

        UpdateChart(Kp_indx,'#chart2', PlasmaData, 'chartemperature', '#7b1fa2 ');

         }
    }

function createChart(Kp_indx,containerId, dataSet, yAccessor, yLabel, titleText, lineColor) {
    // select chart 
    const chart = d3.select(containerId);
     
   // margins of the page
   const margin = { top:40, right: 10, bottom: 20, left: 60 };
    // Get the width and height of the chart container
    const width = parseInt(chart.style('width')) - margin.left - margin.right;
    const height = parseInt(chart.style('height')) - margin.top - margin.bottom;

    // SVG
    //center vertically the svg
    const svg = chart.append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr("viewBox", '0 0  width height')
        .attr('preserveAspectRatio', 'xMinYMin meet')
        .call(responsivefy)
        .append('g')
        .attr('transform', `translate(${margin.left}, ${margin.top})`);


        function responsivefy(svg) {
             
             // Container is the DOM element, svg is appended.
             // Then we measure the container and find its
             // aspect ratio.
             const container = d3.select(svg.node().parentNode),
                 width = parseInt(svg.style('width'), 10),
                 height = parseInt(svg.style('height'), 10),
                 aspect = width / height;
                  
             // Add viewBox attribute to set the value to initial size
             // add preserveAspectRatio attribute to specify how to scale 
             // and call resize so that svg resizes on page load
             svg.attr('viewBox', `0 0 ${width} ${height}`).
             attr('preserveAspectRatio', 'xMinYMid').
             call(resize);
              
             d3.select(window).on('resize.' + container.attr('id'), resize);
   
             function resize() {
                 const targetWidth = parseInt(container.style('width'));
                 svg.attr('width', targetWidth);
                 svg.attr('height', Math.round(targetWidth / aspect));
             }
         }

    //Scales
    const xScale = d3.scaleTime()
        .domain(d3.extent(dataSet, d => d.date))
        .range([0, width]);

    const minY = d3.min(dataSet.filter(d => d[yAccessor] !== 0), d => {
        const value = parseFloat(d[yAccessor]);
            return value; 
        });

    const maxY = d3.max(dataSet, d => {
        const value = parseFloat(d[yAccessor]);
            return value; 
        });

    console.log("Min Value:", minY); 
    console.log("Max Value:", maxY); 

    const yScale = d3.scaleLinear()
        .domain([minY, maxY])
        .range([height, 0])
        .nice();

    // Add the lines
    const line = d3.line() 
        .x(d => xScale(d.date))
        .y(d => yScale(d[yAccessor]))
        .defined(d => d[yAccessor] !== 0 && d[yAccessor] !== null && !isNaN(d[yAccessor]) || (d[yAccessor] < 0 || d[yAccessor] > 0));

    const linePath = svg.append("path")
        .data([dataSet])
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", 'rgb( 154, 157, 154)')
        .attr("stroke-width", 1)
        .attr("d", line(dataSet))
        .attr("clip-path", "url(#clip)");

   

    function getColorsAndIn(dataSet,yAccessor) {
        let parameter = yAccessor;
        const colorsAndIndexes = [
            { speed: 1000, density: 10000, temperature: 100000000, bx: -10, backgroundColor: '#FF0D0D', opacity: 0.8 },
            { speed: 900, density: 5000, temperature: 6000000, bx: -5, backgroundColor: '#FF4E11', opacity: 0.7 },
            { speed: 800, density: 4000, temperature: 50000000, bx: -1, backgroundColor: '#FF8E15', opacity: 0.65 },
            { speed: 700, density: 1000, temperature: 10000000, bx: 0, backgroundColor: '#FAB733', opacity: 0.6 },
            { speed: 600, density: 100, temperature: 5000000, bx: 10, backgroundColor: '#FFFE2A', opacity: 0.55 },
            { speed: 0, density: 0, temperature: 0, bx: 0, backgroundColor: '#09BC04', opacity: 0.5 },
        ];
        
        // Obtener el valor máximo del dataset
        var max = d3.max(dataSet, d => parseFloat(d[yAccessor]));
        console.log("Max value:", max);
        
        
        // Calcular los offsets para el gradiente
        colorsAndIndexes.forEach((colorIndex, i) => {
             // Calcular el offset basado en la posición
             colorIndex.offset = (i / (colorsAndIndexes.length - 1)) * 100;
            });

    console.log(colorsAndIndexes);

    // Crear el gradiente en SVG
    svg.append('defs')
        .append('linearGradient')
        .attr('gradientUnits', 'userSpaceOnUse')
        .attr('id', 'gradient-area')
        .attr('x1', 0)
        .attr('y1', 0)
        .attr('x2', 0)
        .attr('y2', yScale(max))
        .selectAll('stop')
        .data(colorsAndIndexes)
        .enter().append('stop')
        .attr('offset', function(d) { return d.offset + '%'; })
        .attr('style', function(d) { return 'stop-color:' + d.backgroundColor + ';stop-opacity:' + d.opacity; });
           
}
// Llamar a la función
getColorsAndIn(yAccessor);
console.log("radiente",getColorsAndIn)

console.log("elkp",Kp_indx)
 // define the area
 var area = d3.area()
    .x(d => xScale(d.date))
    .y0(height)
    .y1(d => yScale(d[yAccessor]));

    //clipping path to avoid elements spilling out
    svg.append("defs").append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("x", 0)
    .attr("width", width)
    .attr("height", height);
  
     // add first area
  svg.append("path")
      .data([dataSet])
      .attr("class", "area")
      .attr('d', area)
      .attr('style', 'fill: url(#gradient-area);')
      .attr("clip-path", "url(#clip)");

    //zoom 
    const zoom = d3.zoom()
        .scaleExtent([1, 120])
        .translateExtent([[0, 0], [width, height]])
        .extent([[0, 0], [width, height]])
        .on('zoom', zoomed);

     //apply zoom to the graph
     svg.append('rect')
        .attr('width', width)
        .attr('height', height)
        .style("fill", "none")
        .style('pointer-events', 'all')
        .attr("transform", `translate(${margin.left}, ${margin.top})`)
        .call(zoom);

    function zoomed(event) {
        const new_xScale = event.transform.rescaleX(xScale);
 
        svg.select('.x-axis')
            .call(d3.axisBottom(new_xScale).tickFormat(d3.timeFormat('%H:%M')));

        svg.select('.line')
            .attr('d', line.x(d => new_xScale(d.date)));
        
        svg.select('.area')
            .attr('d', area.x(d => new_xScale(d.date)));
           
        svg.selectAll('.dot')
        .attr('cx', d => new_xScale(d.date))
        .attr('cy', d => yScale(d[yAccessor]));

         // Determine the scale factor
         const scaleFactor = event.transform.k;

        // Set a threshold for visibility; adjust this value as needed
         const visibilityThreshold = 5; // This means dots will be visible when zoomed in more than 5 times

        svg.selectAll('.dot')
            .style('opacity', scaleFactor > visibilityThreshold ? 1 : 0); // Show dots if zoomed in enough
     }

    //X axis
    svg.append("g")
        .attr("class", "x-axis")
        .attr("clip-path", "url(#clip)")
        .style("color",'rgb(154, 157, 154)')
        .attr("stroke-width", 3)
        .style("font",'Roboto')
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M')));

    //Y axis
    svg.append("g")
        .attr("class", "y-axis")
        .attr("stroke-width", 1)
        .style("color",'rgb( 154, 157, 154)')
        .call(d3.axisLeft(yScale)
        .ticks(4)
        .tickFormat(function(d) {
            return d > 9999 ? d3.format(".2e")(d) : d3.format(",.0f")(d);
         }))
        .call(g => g.selectAll(".tick line").clone()
        .attr("x2", width )
        .attr("stroke-opacity", 0.1));
      
    //Y label 
    svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left +10)
        .attr("x", -height / 2)
        .attr("dy", "0.5em")
        .style("text-anchor", "middle")
        .text(yLabel)
        .style("fill",'rgb( 154, 157, 154)') 
        .style("font-weight", "bold"); 

    //chart title
    svg.append("text")
        .attr("x", width-1780)
        .attr("y", -15 )
        .attr("text-anchor", "middle")
        .attr("font-size", "18px")
        .attr("fill",' grey') 
        .style("font-family","Roboto, sans-serif")
        .text(titleText);

    // Create a group for the dots
    const dotsGroup = svg.append('g')
        .attr('clip-path', 'url(#clip)');

    // Append the dots but set their initial opacity to 0
    const dots = dotsGroup.selectAll('.dot')
        .data(dataSet)
        .enter().append('circle')
        .attr('class', 'dot')
        .attr('cx', d => xScale(d.date))
        .attr('cy', d => yScale(d[yAccessor]))
        .attr('r', 1) // Set a larger radius for visibility
        .attr('fill','rgb( 154, 157, 154)')
        .style('opacity', 0.5) // Initially hidden
        .on('mouseover', function(event, d) {
            d3.select(this).transition().duration(200).attr('fill', 'orange').attr('r', 5);
            tooltip.transition().duration(200).style('opacity', 0.9);
            const [x, y] = d3.pointer(event, this);
            tooltip.html(`Fecha: ${d3.timeFormat('%d %b %H:%M')(d.date)}<br/>Valor: ${d[yAccessor]}`)
                .style('left', (event.pageX + 5) + 'px')
                .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
            d3.select(this).transition().duration(200).attr('fill', 'rgb( 154, 157, 154)').attr('r', 3);
            tooltip.transition().duration(200).style('opacity', 0);
        });

    // Add mouse events to the line
    linePath.on('mouseover', function() {
        d3.select(this).style('opacity', 1); 
        })
        .on('mousemove', function(event) {
            const mouseX = d3.pointer(event)[0]; // Get mouse X position
            const x0 = xScale.invert(mouseX); // Convert mouse X to the corresponding date
            const index = d3.bisectLeft(dataSet.map(d => d.date), x0); // Find the index of the closest date        
            // Select the nearest data point
            const closestDataPoint = dataSet[index];        
            // Highlight the closest dot
            if (closestDataPoint) {
                dots.transition().duration(200).style('opacity', 0); // Hide all dots
                d3.select(dots.nodes()[index]).transition().duration(200).attr('fill', 'orange').attr('r', 5); // Highlight the closest dot
                }
         })
        .on('mouseout', function() {
            dots.style('opacity', 0); // Hide dots when not hovering
            });

    // Tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0)
        .style('position', 'absolute') // Ensure the tooltip is absolutely positioned
        .style('pointer-events', 'none'); // Prevent mouse events from interfering
        }


//funcion para crear el grafico combinado
function createCombinedMagChart(containerId, dataSet, titleText,yLabel) {
    // Select chart 
    const chart = d3.select(containerId);
     
    // margins of the page
    const margin = { top:40, right: 10, bottom: 20, left: 60 };
    // Get the width and height of the chart container
    const width = parseInt(chart.style('width')) - margin.left - margin.right;
    const height = parseInt(chart.style('height')) - margin.top - margin.bottom;

    // SVG
    //center vertically the svg
    const svg = chart.append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .append('g')
        .attr('transform', `translate(${margin.left}, ${margin.top})`);
    // Scales
    const xScale = d3.scaleTime()
        .domain(d3.extent(dataSet, d => d.date))
        .range([0, width]);

    const minY = d3.min(dataSet, d => Math.min(d.chartbx, d.chartby, d.chartbz));
    const maxY = d3.max(dataSet, d => Math.max(d.chartbx, d.chartby, d.chartbz));

    
    const yScale = d3.scaleLinear()
        .domain([minY, maxY])
        .range([height, 0])
        .nice();
    const zoom = d3.zoom()
        .scaleExtent([1, 120])
        .translateExtent([[0, 0], [width, height]])
        .extent([[0, 0], [width, height]])
        .on('zoom', zoomed);

         //apply zoom to the graph
        svg.append('rect')
        .attr('width', width)
        .attr('height', height)
        .style("fill", "none")
        .style('pointer-events', 'all')
        .attr("transform", `translate(${margin.left}, ${margin.top})`)
        .call(zoom);
    function zoomed(event) {
    const new_xScale = event.transform.rescaleX(xScale);

    // Update the x-axis
    svg.select('.x-axis')
        .call(d3.axisBottom(new_xScale).tickFormat(d3.timeFormat('%H:%M')));

    // Update each line based on the new xScale, keeping yScale fixed
    lines.forEach(lineInfo => {
        const lineData = dataSet.map(d => ({ date: d.date, value: d[lineInfo.key] }));
        svg.selectAll(`.line-${lineInfo.key}`)
            .attr('d', d3.line()
                .x(d => new_xScale(d.date)) // Use new xScale
                .y(d => yScale(d.value)) // Keep using the original yScale
                .defined(d => d.value !== 0 && d.value !== null && !isNaN(d.value))
            );
    });

    // Update dots based on new xScale, keeping yScale fixed
    svg.selectAll('.dot')
        .attr('cx', d => new_xScale(d.date))
        .attr('cy', d => yScale(d[yAccessor])); // Keep using the original yScale

    // Determine the scale factor for dot visibility
    const scaleFactor = event.transform.k;

    // Set a threshold for visibility; adjust this value as needed
    const visibilityThreshold = 5; // Dots will be visible when zoomed in more than 5 times

    svg.selectAll('.dot')
        .style('opacity', scaleFactor > visibilityThreshold ? 1 : 0); // Show dots if zoomed in enough
    }
    // Clipping path to avoid elements spilling out
    svg.append("defs").append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0) // Ensure the y position is 0
    .attr("width", width)
    .attr("height", height);
    // Line function
    const line = d3.line()
        .x(d => xScale(d.date))
        .y(d => yScale(d.value))
        .defined(d => d.value !== 0 && d.value !== null && !isNaN(d.value));

    // Create lines for each value
    const lines = [
        { key: 'chartbx', color: '#DC143C', label: 'Bx', class: 'label-bx'  },
        { key: 'chartby', color: '#db7e21', label: 'By', class: 'label-by'  },
        { key: 'chartbz', color: '#7edb21', label: 'Bz', class: 'label-bz'  }
    ];

    // Create tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0)
        .style('position', 'absolute')
        .style('pointer-events', 'none');

    lines.forEach(lineInfo => {
        // Create a new dataset for the line
        const lineData = dataSet.map(d => ({ date: d.date, value: d[lineInfo.key] }));

        // Append the line
        const linePath = svg.append("path")
            .data([lineData])
            .attr("class", `line line-${lineInfo.key}`)
            .attr("stroke", lineInfo.color)
            .attr("stroke-width", 1)
            .attr("fill",'none')
            .attr("clip-path", "url(#clip)")
            .attr("d", line(lineData));

        // Add mouse events for tooltip
        linePath.on('mouseover', function() {
            d3.select(this).style('opacity', 0.8);
        })
        .on('mousemove', function(event) {
            const mouseX = d3.pointer(event)[0]; // Get mouse X position
            const x0 = xScale.invert(mouseX); // Convert mouse X to the corresponding date
            const index = d3.bisectLeft(lineData.map(d => d.date), x0); // Find the index of the closest date

            // Select the nearest data point
            const closestDataPoint = lineData[index];

            // Show tooltip if a data point is found
            if (closestDataPoint) {
                tooltip.transition().duration(200).style('opacity', 0.9);
                tooltip.html(`Date: ${d3.timeFormat('%d %b %H:%M')(closestDataPoint.date)}<br>${lineInfo.label}: ${closestDataPoint.value}`)
                    .style('left', (event.pageX + 5) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
            }
        })
        .on('mouseout', function() {
            d3.select(this).style('opacity', 1);
            tooltip.transition().duration(500).style('opacity', 0);
        });
    });

    // // X axis
    svg.append("g")
        .attr("class", "x-axis")
        .attr("clip-path", "url(#clip)")
        .style("color",'rgb(154, 157, 154)')
        .attr("stroke-width", 3)
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M')));

    // Y axis
    svg.append("g")
        .attr("class", "y-axis")
        .attr("Stroke-width", 1)
        .style("color",'rgb(154, 157, 154)')
        .call(d3.axisLeft(yScale)
        .ticks(4)
        .tickFormat(function(d) {
            return d > 9999 ? d3.format(".2e")(d) : d3.format(",.0f")(d);
         }))
        .call(g => g.selectAll(".tick line").clone()
        .attr("x2", width )
        .attr("stroke-opacity", 0.1));

         //Y label 
         svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left +10)
        .attr("x", -height / 2)
        .attr("dy", "0.5em")
        .style("text-anchor", "middle")
        .text(yLabel)
        .style("fill",'rgb( 154, 157, 154)') 
        .style("font-weight", "bold"); 
    
    // Add legend
    const legend = svg.append("g")
        .attr("transform", `translate(-58, 0)`); // Position the legend

    lines.forEach((lineInfo, i) => {
        legend.append("rect")
            .attr("x", (i * 25)+60)
            .attr("y", -20)
            .attr("width", 15)
            .attr("height", 15)
            .attr("fill", lineInfo.color);

        legend.append("text")
            .attr("x", (i * 25)+60)
            .attr("y", -25)
            .attr("font-size", "18px")
            .attr("fill",' grey') 
            .style("font-family","Roboto, sans-serif")
            .text(lineInfo.label);
    });
}
//funcion para actualizar el grafico combinado 
function UpdateCombinedMagChart(containerId, dataSet) {
    const chart = d3.select(containerId);
    const margin = { top:40, right: 10, bottom: 20, left: 60 };
    const width = 1390 - margin.left - margin.right;
    const height = 180 - margin.top - margin.bottom;

    // Select the existing SVG and remove previous elements
    let svg = chart.select("svg");
    svg.selectAll('.line').remove();
    svg.selectAll('.dot').remove();
    svg.selectAll('.x-axis').remove();
    svg.selectAll('.y-axis').remove();

    if (svg.empty()) {
        svg = chart.append('svg')
            .attr('width', "100%")
            .attr('height', "100%")
            .append('g')
            .attr('transform', `translate(${margin.left}, 45)`);
    } else {
        svg = svg.select('g');
    }

    // Scales
    const xScale = d3.scaleTime()
        .domain(d3.extent(dataSet, d => d.date))
        .range([0, width]);

    const minY = d3.min(dataSet, d => Math.min(d.chartbx, d.chartby, d.chartbz));
    const maxY = d3.max(dataSet, d => Math.max(d.chartbx, d.chartby, d.chartbz));

    const yScale = d3.scaleLinear()
        .domain([minY, maxY])
        .range([height, 0])
        .nice();

    // Create tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0)
        .style('position', 'absolute')
        .style('pointer-events', 'none');

    // Create lines for each value
    const lines = [
        { key: 'chartbx', color: '#e74c3c', label: 'BX' },
        { key: 'chartby', color: '#92d050', label: 'BY' },
        { key: 'chartbz', color: '#673ab7', label: 'BZ' }
    ];

    lines.forEach(lineInfo => {
        // Create a new dataset for the line
        const lineData = dataSet.map(d => ({ date: d.date, value: d[lineInfo.key] }));

        // Append the line
        const linePath = svg.append("path")
            .data([lineData])
            .attr("class", "line")
            .attr("fill", "none")
            .attr("stroke", lineInfo.color)
            .attr("stroke-width", 1)
            .attr("d", d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.value))
                .defined(d => d.value !== 0 && d.value !== null && !isNaN(d.value)));

        // Add mouse events for tooltip
        linePath.on('mouseover', function() {
            d3.select(this).style('opacity', 0.8);
        })
        .on('mousemove', function(event) {
            const mouseX = d3.pointer(event)[0]; // Get mouse X position
            const x0 = xScale.invert(mouseX); // Convert mouse X to the corresponding date
            const index = d3.bisectLeft(lineData.map(d => d.date), x0); // Find the index of the closest date

            // Select the nearest data point
            const closestDataPoint = lineData[index];

            // Show tooltip if a data point is found
            if (closestDataPoint) {
                tooltip.transition().duration(200).style('opacity', 0.9);
                tooltip.html(`Date: ${d3.timeFormat('%d %b %H:%M')(closestDataPoint.date)}<br>${lineInfo.label}: ${closestDataPoint.value}`)
                    .style('left', (event.pageX + 5) + 'px')
                    .style('top', (event .pageY - 28) + 'px');
            }
        })
        .on('mouseout', function() {
            d3.select(this).style('opacity', 1);
            tooltip.transition().duration(500).style('opacity', 0);
        });
    });

    // X axis
    svg.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M')));

    // Y axis
    svg.append("g")
        .attr("class", "y-axis")
        .call(d3.axisLeft(yScale).ticks(4));

    // Apply the zoom behavior to the updated chart
    const zoom = d3.zoom()
        .scaleExtent([1, 120])
        .translateExtent([[0, 0], [width, height]])
        .extent([[0, 0], [width, height]])
        .on('zoom', zoomed);

    svg.append('rect')
        .attr('width', width)
        .attr('height', height)
        .style("fill", "none")
        .style('pointer-events', 'all')
        .call(zoom);

    function zoomed(event) {
        const new_xScale = event.transform.rescaleX(xScale);

        // Update the x-axis
        svg.select('.x-axis')
            .call(d3.axisBottom(new_xScale).tickFormat(d3.timeFormat('%H:%M')));

        // Update each line based on the new xScale, keeping yScale fixed
        lines.forEach(lineInfo => {
            const lineData = dataSet.map(d => ({ date: d.date, value: d[lineInfo.key] }));
            svg.selectAll(`.line`)
                .attr('d', d3.line()
                    .x(d => new_xScale(d.date)) // Use new xScale
                    .y(d => yScale(d.value)) // Keep using the original yScale
                    .defined(d => d.value !== 0 && d.value !== null && !isNaN(d.value))
                )
                .attr("clip-path", "url(#clip)");
        });

        // Update dots based on new xScale, keeping yScale fixed
        svg.selectAll('.dot')
            .attr('cx', d => new_xScale(d.date))
            .attr('cy', d => yScale(d[yAccessor])); // Keep using the original yScale

        // Determine the scale factor for dot visibility
        const scaleFactor = event.transform.k;

        // Set a threshold for visibility; adjust this value as needed
        const visibilityThreshold = 5; // Dots will be visible when zoomed in more than 5 times

        svg.selectAll('.dot')
            .style('opacity', scaleFactor > visibilityThreshold ? 1 : 0); // Show dots if zoomed in enough
    }
}


// Función para actualizar la fecha y hora
function updateDate() {
    const now = new Date();
    const formattedDate = now.toLocaleString(); // Formato de fecha y hora
    d3.select('#currentDate') // Selecciona el elemento con id 'currentDate'
        .text(formattedDate); // Actualiza el texto
        }

// Llama a la función al cargar la página
updateDate();
// Actualiza cada minuto (60000 ms)
setInterval(updateDate, 1000);


function updateLastUpdate() {
    const now = new Date();
    const formattedTime = now.toLocaleTimeString(); // Formato de hora y minuto
    d3.select('#lastUpdate') // Selecciona el elemento con id 'lastUpdate'
    .text(`Última actualización: ${formattedTime}`); // Actualiza el texto
    }


function UpdateChart(Kp_indx,containerId, dataSet, yAccessor,lineColor){
    console.log("Y:",yAccessor)
    // select chart 
    const chart = d3.select(containerId);
   // margins of the page
   const margin = { top:40, right: 10, bottom: 20, left: 60 };
    // Get the width and height of the chart container
    const width = parseInt(chart.style('width')) - margin.left - margin.right;
    const height = parseInt(chart.style('height')) - margin.top - margin.bottom;

    // Seleccionar el contenedor SVG y eliminar los elementos anteriores
    let svg = chart.select("svg");
    svg.selectAll('.line').remove();
    svg.selectAll('.dot').remove();
    svg.selectAll('.x-axis').remove();
    svg.selectAll('.y-axis').remove();
    svg.selectAll('.tooltip').remove();
    svg.selectAll('.linePath').remove();
    svg.selectAll('.rect').remove();
    svg.selectAll('.area').remove();

    if (svg.empty()) {
        svg = chart.append('svg')
        .attr('width','100%')
        .attr('height','100%')
        .append('g')
        .attr('transform',`translate(${margin.left}, 45)`);

    } else {
        svg = svg.select('g');
    }

    //Scales
    const xScale = d3.scaleTime()
        .domain(d3.extent(dataSet, d => d.date))
        .range([0, width+10]);

    const minY = d3.min(dataSet.filter(d => d[yAccessor] !== 0), d => {
        const value = parseFloat(d[yAccessor]);
        return value; 
    });
    
    const maxY = d3.max(dataSet, d => {
    const value = parseFloat(d[yAccessor]);
        return value; 
    });

    console.log("Min Value:", minY); 
    console.log("Max Value:", maxY); 

    const yScale = d3.scaleLinear()
        .domain([minY, maxY])
        .range([height, 0])
        .nice();

    //line graph 
    const line = d3.line()
        .x(d => xScale(d.date))
        .y(d => yScale(d[yAccessor]))
        .defined(d => d[yAccessor] !== 0 && d[yAccessor] !== null && !isNaN(d[yAccessor]) || (d[yAccessor] < 0 || d[yAccessor] > 0));

    //append line
    const linePath = svg.append("path")
        .data([dataSet])
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke",'rgb( 154, 157, 154)')
        .attr("stroke-width", 1)
        .attr("d", line(dataSet))
        .attr("clip-path", "url(#clip)");
        function getColorsAndIn(dataSet,yAccessor) {
        let parameter = yAccessor;
        const colorsAndIndexes = [
            { speed: 1000, density: 10000, temperature: 100000000, bx: -10, backgroundColor: '#FF0D0D', opacity: 0.8 },
            { speed: 900, density: 5000, temperature: 6000000, bx: -5, backgroundColor: '#FF4E11', opacity: 0.7 },
            { speed: 800, density: 4000, temperature: 50000000, bx: -1, backgroundColor: '#FF8E15', opacity: 0.65 },
            { speed: 700, density: 1000, temperature: 10000000, bx: 0, backgroundColor: '#FAB733', opacity: 0.6 },
            { speed: 600, density: 100, temperature: 5000000, bx: 10, backgroundColor: '#FFFE2A', opacity: 0.55 },
            { speed: 0, density: 0, temperature: 0, bx: 0, backgroundColor: '#09BC04', opacity: 0.5 },
        ];
        
        // Obtener el valor máximo del dataset
        var max = d3.max(dataSet, d => parseFloat(d[yAccessor]));
        console.log("Max value:", max);
        
        
        // Calcular los offsets para el gradiente
        colorsAndIndexes.forEach((colorIndex, i) => {
             // Calcular el offset basado en la posición
             colorIndex.offset = (i / (colorsAndIndexes.length - 1)) * 100;
            });

    console.log(colorsAndIndexes);

    // Crear el gradiente en SVG
    svg.append('defs')
        .append('linearGradient')
        .attr('gradientUnits', 'userSpaceOnUse')
        .attr('id', 'gradient-area')
        .attr('x1', 0)
        .attr('y1', 0)
        .attr('x2', 0)
        .attr('y2', yScale(max))
        .selectAll('stop')
        .data(colorsAndIndexes)
        .enter().append('stop')
        .attr('offset', function(d) { return d.offset + '%'; })
        .attr('style', function(d) { return 'stop-color:' + d.backgroundColor + ';stop-opacity:' + d.opacity; });
           
}

// Llamar a la función
getColorsAndIn(yAccessor);
console.log("radiente",getColorsAndIn)

    // define the area
    var area = d3.area()
    .x(d => xScale(d.date))
    .y0(height)
    .y1(d => yScale(d[yAccessor]));

    var defs = svg.append("defs");

    //clipping path to avoid elements spilling out
    svg.append("defs").append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("x", 0)
    .attr("width", width)
    .attr("height", height);

     // add first area
    svg.append("path")
      .data([dataSet])
      .attr("class", "area")
      .attr('d', area)
      .attr('style', 'fill: url(#gradient-area);')
      .attr("clip-path", "url(#clip)");


    const zoom = d3.zoom()
        .scaleExtent([1, 240])
        .translateExtent([[0, 0], [width+10, height]])
        .extent([[0, 0], [width+10, height]])
        .on('zoom', zoomed);

        //apply zoom to the graph
     svg.append('rect')
        .attr('width', width)
        .attr('height', height)
        .style("fill", "none")
        .style('pointer-events', 'all')
        .attr("transform", `translate(${margin.left}, ${margin.top})`)
        .call(zoom);

    function zoomed(event) {
        
        const new_xScale = event.transform.rescaleX(xScale);

        svg.select('.x-axis')
            .call(d3.axisBottom(new_xScale).tickFormat(d3.timeFormat('%H:%M')));

        svg.select('.line')
            .attr('d', line.x(d => new_xScale(d.date)));

        svg.select('.area')
            .attr('d', area.x(d => new_xScale(d.date)));

        svg.selectAll('.dot')
            .attr('cx', d => new_xScale(d.date))
            .attr('cy', d => yScale(d[yAccessor]));
        }

    // Clipping path
    svg.append("defs").append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("x", 0)
        .attr("width", width)
        .attr("height", height);

    // X Axis
    svg.append("g")
        .attr("class", "x-axis")
        .attr("clip-path", "url(#clip)")
        .attr("stroke-width", 1)
        .style("color",'rgb(154, 157, 154)')
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M')));

    // Y Axis
    svg.append("g")
        .attr("class", "y-axis")
        .attr("stroke-width", 1)
        .style("color",'rgb( 154, 157, 154)')
        .call(d3.axisLeft(yScale)
            .ticks(4)
            .tickFormat(function(d) {
                return d > 9999 ? d3.format(".2e")(d) : d3.format(",.0f")(d);
            }))

        .call(g => g.selectAll(".tick line").clone()
            .attr("x2", width)
            .attr("stroke-opacity", 0.1));
        // Create a group for the dots
        const dotsGroup = svg.append('g')
        .attr('clip-path', 'url(#clip)');

        // Append the dots   
        const dots = dotsGroup.selectAll('.dot')
        .data(dataSet)
        .enter().append('circle')
        .attr('class', 'dot')
        .attr('cx', d => xScale(d.date))
        .attr('cy', d => yScale(d[yAccessor]))
        .attr('r', 1) // Set a larger radius for visibility
        .attr('fill','rgb( 154, 157, 154)')
        .style('opacity', 0.5) // Initially hidden
        .on('mouseover', function(event, d) {
            d3.select(this).transition().duration(200).attr('fill', 'orange').attr('r', 5);
            tooltip.transition().duration(200).style('opacity', 0.9);
            const [x, y] = d3.pointer(event, this);
            tooltip.html(`Fecha: ${d3.timeFormat('%d %b %H:%M')(d.date)}<br/>Valor: ${d[yAccessor]}`)
                .style('left', (event.pageX + 5) + 'px')
                .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
            d3.select(this).transition().duration(200).attr('fill', 'rgb( 154, 157, 154)').attr('r', 3);
            tooltip.transition().duration(200).style('opacity', 0);
        });

    // Tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0)
        .style('position', 'absolute') // Ensure the tooltip is absolutely positioned
        .style('pointer-events', 'none'); // Prevent mouse events from interfering

        console.log("data en linea:",dataSet)

}

</script>
  </body>
</html>